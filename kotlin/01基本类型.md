# 基本类型

- [基本类型](#基本类型)
  - [数字](#数字)
    - [整数](#整数)
    - [浮点数](#浮点数)
    - [字面常量](#字面常量)
    - [数字字面值中的下划线（1.1）](#数字字面值中的下划线11)
    - [表示方式](#表示方式)
    - [显式转换](#显式转换)
    - [位运算](#位运算)
    - [浮点数比较](#浮点数比较)
    - [字符](#字符)
  - [布尔](#布尔)
  - [数组](#数组)
    - [原生类型数组](#原生类型数组)
  - [无符号整型](#无符号整型)

Kotlin 中，所有东西都是对象

## 数字

### 整数

| 类型  | bit | min         | max        |
| ----- | --- | ----------- | ---------- |
| Byte  | 8   | -128        | 127        |
| Short | 16  | -32768      | 32767      |
| Int   | 32  | -2147483648 | 2147483647 |
| Long  | 64  | 2^63        | 2^63-1     |

所有未超过 Int 最大值的整型值初始化的变量都会推断为 Int，如果超过了，推断为 Long，如果需要显式指定 Long 类型，在数字后加 L。

```kt
val a = 1 //Int
val b = 30000000000 //Long
val c = 1L //Long
val d: Byte = 1
```

### 浮点数

| 类型   | bit | 有效数字 bit | 指数 bit | 十进制位数 |
| ------ | --- | ------------ | -------- | ---------- |
| Float  | 32  | 24           | 8        | 6-7        |
| Double | 64  | 53           | 11       | 15-16      |

以小数初始化的变量，会推断为 Double 类型。显式指定 Float，加 F 后缀。如果 Float 数值包含多余 6~7 位十进制数，会舍入。

```kt
val pi = 3.14 //Double
val e = 2.7182818284 //Double
val eF = 2.7182818284 //Float 实际值为 2.7182817
```

**Kotlin 中没有隐式数字转换，例如 Double 不能自动转换位 Float Int 等。需要使用显式转换。**

```kt
fun main(){
  fun printDouble(d: Double) { print(d)}

  val i = 1
  val d = 1.1
  val f = 1.1f

  printDouble(d) //correct
  printDouble(f) //错误，类型不匹配
}
```

### 字面常量

- 十进制：123
  - Long 类型用 L 标记：123L
- 十六进制：0x0F
- 二进制：0b00001011

不支持八进制

- 默认 Double：123.5、123.5e10
- Float 类型用 F 标记：123.5F

### 数字字面值中的下划线（1.1）

使用下划线，更易读

```kt
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### 表示方式

jvm 中，数字存储为原生类型，除非使用可空的引用，如 Int? 或泛型，会把数字装箱。

不一定保留同一性，但保留了相等性。大于 127 的整数，多次装箱后，是不同的对象，但是他们的值相同。

### 显式转换

- toByte(): Byte
- toShort(): Short
- toInt(): Int
- toLong(): Long
- toFloat(): Float
- toDouble(): Double
- toChar(): Char

### 位运算

- shl(bits) 有符号左移
- shr(bits) 有符号右移
- ushr(bits) 无符号右移
- and(bits) 位与
- or(bits) 位或
- xor(bits) 位异或
- inv() 位非

### 浮点数比较

遵循 IEEE 754 浮点运算标准

操作数是非静态类型时（例如 Any、泛型等）有例外

### 字符

Char 表示，不能直接当作数字

字面值用单引号，特殊字符用反斜杠转义

`\t \b \n \r \' \" \\ \$`

可显式转换为 Int 数字

```kt
fun decimalDigitValue(c: Char): Int {
    if (c !in '0'..'9')
        throw IllegalArgumentException("Out of range")
    return c.toInt() - '0'.toInt() // 显式转换为数字
}
```

## 布尔

有 true、false 两个值，若需要可空引用布尔会被装箱

## 数组

Array 表示，定义了 get 与 set 函数（按照重载约定，转变为 []），以及 size 属性，以及一些其他有用的成员函数

```kt
class Array<T> private constructor(){
  val size: Int
  operator fun get(index: Int): T
  operator fun set(index: Int, value: T): Unit

  operator fun iterator(): Iterator<T>
}
```

可以使用 arrayOf() 来创建数组，arrayOfNulls() 可以用于创建一个指定大小，所有元素位空的数组

还可以用接受数组大小一级一个函数的构造函数，该概述用作给每个元素处理初始值

```kt
// 创建一个 Array<String> 初始化为 ["0", "1", "4", "9", "16"]
val asc Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

`[]` 运算符代表调用成员函数 get() 与 set()

Kotlin 数组是不形变的，不能把 `Array<String>` 赋值给 `Array<Any>`，以防止可能的运行时失败。（但是可以使用 `Array<out Any>`）

### 原生类型数组

Kotlin 有无装箱开销的类来表示原生类型数组：ByteArray、ShortArray、IntArray 等。这些类与 Array 没有继承关系，但是又相同的方法属性集，他们也有响应的工厂方法。

```kt
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]

// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组
var arr = IntArray(5)

// 例如：用常量初始化数组中的值
// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组
var arr = IntArray(5) { 42 }

// 例如：使用 lambda 表达式初始化数组中的值
// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）
var arr = IntArray(5) { it * 1 }
```

## 无符号整型

- kotlin.UByte：无符号 8 比特整数，0 - 255
- kotlin.UShort：无符号 16 比特整数，0 - 65535
- kotlin.UInt
- kotlin.ULong

